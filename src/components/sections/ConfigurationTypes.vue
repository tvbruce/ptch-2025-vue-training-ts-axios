<template>
    <div class="configuration-types">
        <div class="section-intro">
            <h2>é…ç½®å‹åˆ¥ç®¡ç†</h2>
            <p class="intro-text">
                è‰¯å¥½çš„é…ç½®ç®¡ç†æ˜¯å»ºæ§‹å¯ç¶­è­·å’Œå¯æ“´å±•æ‡‰ç”¨ç¨‹å¼çš„åŸºç¤ã€‚æœ¬ç« ç¯€å°‡æ¢è¨å¦‚ä½•åœ¨ TypeScript ä¸­
                è¨­è¨ˆå’Œå¯¦ç¾å‹åˆ¥å®‰å…¨çš„é…ç½®ç³»çµ±ï¼Œæ¶µè“‹ç’°å¢ƒè¨­å®šã€API é…ç½®å’Œæ‡‰ç”¨ç¨‹å¼åƒæ•¸ç®¡ç†ã€‚
            </p>
        </div>

        <div class="config-principles">
            <h3>é…ç½®ç®¡ç†åŸå‰‡</h3>
            <div class="principles-grid">
                <div class="principle-card">
                    <h4>ğŸ—ï¸ å‹åˆ¥å®‰å…¨</h4>
                    <p>ä½¿ç”¨ TypeScript å®šç¾©åš´æ ¼çš„é…ç½®ä»‹é¢ï¼Œåœ¨ç·¨è­¯æ™‚æœŸæ•ç²éŒ¯èª¤</p>
                </div>
                <div class="principle-card">
                    <h4>ğŸ”§ åˆ†å±¤é…ç½®</h4>
                    <p>æ”¯æ´é–‹ç™¼ã€æ¸¬è©¦ã€ç”Ÿç”¢ç­‰ä¸åŒç’°å¢ƒçš„é…ç½®ç¹¼æ‰¿å’Œè¦†è“‹</p>
                </div>
                <div class="principle-card">
                    <h4>ğŸ” é©—è­‰æ©Ÿåˆ¶</h4>
                    <p>åœ¨æ‡‰ç”¨ç¨‹å¼å•Ÿå‹•æ™‚é©—è­‰é…ç½®çš„å®Œæ•´æ€§å’Œæœ‰æ•ˆæ€§</p>
                </div>
                <div class="principle-card">
                    <h4>ğŸ” å®‰å…¨æ€§</h4>
                    <p>ä¿è­·æ•æ„Ÿé…ç½®è³‡è¨Šï¼Œé¿å…æ„å¤–æ´©éœ²</p>
                </div>
            </div>
        </div>

        <div class="config-types">
            <h3>é…ç½®å‹åˆ¥å®šç¾©</h3>
            <CodeBlock title="åŸºç¤é…ç½®å‹åˆ¥" :code="configTypesCode" language="typescript" explanation="å®šç¾©å®Œæ•´çš„æ‡‰ç”¨ç¨‹å¼é…ç½®å‹åˆ¥çµæ§‹" />
        </div>

        <div class="config-manager">
            <h3>é…ç½®ç®¡ç†å™¨</h3>
            <CodeBlock title="ConfigManager é¡åˆ¥" :code="configManagerCode" language="typescript"
                explanation="å¯¦ç¾å‹åˆ¥å®‰å…¨çš„é…ç½®ç®¡ç†å™¨" />
        </div>

        <div class="environment-configs">
            <h3>ç’°å¢ƒé…ç½®</h3>
            <div class="env-tabs">
                <button v-for="env in environments" :key="env.id" class="tab-button"
                    :class="{ active: activeEnv === env.id }" @click="activeEnv = env.id">
                    {{ env.title }}
                </button>
            </div>

            <div class="env-content">
                <div v-for="env in environments" :key="env.id" v-show="activeEnv === env.id">
                    <CodeBlock :title="env.title" :code="env.code" language="typescript"
                        :explanation="env.explanation" />
                </div>
            </div>
        </div>

        <div class="config-validation">
            <h3>é…ç½®é©—è­‰</h3>
            <CodeBlock title="é…ç½®é©—è­‰ç³»çµ±" :code="configValidationCode" language="typescript"
                explanation="å¯¦ç¾å®Œæ•´çš„é…ç½®é©—è­‰å’ŒéŒ¯èª¤è™•ç†æ©Ÿåˆ¶" />
        </div>

        <div class="dynamic-config">
            <h3>å‹•æ…‹é…ç½®</h3>
            <div class="dynamic-examples">
                <div class="dynamic-tabs">
                    <button v-for="example in dynamicExamples" :key="example.id" class="tab-button"
                        :class="{ active: activeDynamic === example.id }" @click="activeDynamic = example.id">
                        {{ example.title }}
                    </button>
                </div>

                <div class="dynamic-content">
                    <div v-for="example in dynamicExamples" :key="example.id" v-show="activeDynamic === example.id">
                        <CodeBlock :title="example.title" :code="example.code" language="typescript"
                            :explanation="example.explanation" />
                    </div>
                </div>
            </div>
        </div>

        <div class="practical-usage">
            <h3>å¯¦éš›æ‡‰ç”¨ç¯„ä¾‹</h3>
            <CodeBlock title="å®Œæ•´ä½¿ç”¨ç¯„ä¾‹" :code="usageExampleCode" language="typescript" explanation="å±•ç¤ºå¦‚ä½•åœ¨å¯¦éš›å°ˆæ¡ˆä¸­ä½¿ç”¨é…ç½®ç®¡ç†ç³»çµ±"
                :runnable="true" @run="runExample" />
        </div>

        <div class="security-practices">
            <h3>å®‰å…¨æœ€ä½³å¯¦è¸</h3>
            <div class="security-grid">
                <div class="security-card">
                    <h4>ğŸ” æ•æ„Ÿè³‡æ–™ä¿è­·</h4>
                    <ul>
                        <li>ä½¿ç”¨ç’°å¢ƒè®Šæ•¸å­˜æ”¾ API é‡‘é‘°</li>
                        <li>é¿å…åœ¨å‰ç«¯ç¨‹å¼ç¢¼ä¸­ç¡¬ç·¨ç¢¼å¯†ç¢¼</li>
                        <li>å¯¦ç¾é…ç½®è³‡æ–™çš„åŠ å¯†å­˜å„²</li>
                        <li>å®šæœŸè¼ªæ›æ•æ„Ÿèªè­‰è³‡è¨Š</li>
                    </ul>
                </div>

                <div class="security-card">
                    <h4>ğŸ›¡ï¸ å­˜å–æ§åˆ¶</h4>
                    <ul>
                        <li>å¯¦ç¾åŸºæ–¼è§’è‰²çš„é…ç½®å­˜å–</li>
                        <li>è¨­å®šé…ç½®ä¿®æ”¹çš„å¯©è¨ˆæ—¥èªŒ</li>
                        <li>é™åˆ¶é…ç½®ä¿®æ”¹çš„æ¬Šé™ç¯„åœ</li>
                        <li>ä½¿ç”¨å®‰å…¨çš„é…ç½®å‚³è¼¸æ–¹å¼</li>
                    </ul>
                </div>

                <div class="security-card">
                    <h4>ğŸ” ç›£æ§èˆ‡å¯©è¨ˆ</h4>
                    <ul>
                        <li>è¨˜éŒ„æ‰€æœ‰é…ç½®è®Šæ›´æ“ä½œ</li>
                        <li>å¯¦ç¾é…ç½®ç•°å¸¸çš„å³æ™‚å‘Šè­¦</li>
                        <li>å®šæœŸæª¢æŸ¥é…ç½®çš„ä¸€è‡´æ€§</li>
                        <li>å»ºç«‹é…ç½®å‚™ä»½å’Œæ¢å¾©æ©Ÿåˆ¶</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="navigation-footer">
            <button class="btn-complete" @click="completeSection">
                å®Œæˆæœ¬ç« ç¯€
            </button>
        </div>
    </div>
</template>

<script setup lang="ts">
import { ref } from 'vue'
import CodeBlock from '@/components/common/CodeBlock.vue'

const emit = defineEmits<{
    complete: []
}>()

const activeEnv = ref('development')
const activeDynamic = ref('feature-flags')

const configTypesCode = `// å®Œæ•´çš„é…ç½®å‹åˆ¥å®šç¾©
// åŸºç¤é…ç½®ä»‹é¢
interface BaseConfig {
  app: AppConfig
  api: ApiConfig
  database: DatabaseConfig
  cache: CacheConfig
  logging: LoggingConfig
  security: SecurityConfig
  features: FeatureFlags
}

// æ‡‰ç”¨ç¨‹å¼é…ç½®
interface AppConfig {
  name: string
  version: string
  environment: 'development' | 'testing' | 'staging' | 'production'
  port: number
  host: string
  debug: boolean
  cors: {
    enabled: boolean
    origins: string[]
    credentials: boolean
  }
}

// API é…ç½®
interface ApiConfig {
  baseUrl: string
  timeout: number
  retries: number
  rateLimit: {
    enabled: boolean
    maxRequests: number
    windowMs: number
  }
  endpoints: {
    auth: string
    users: string
    products: string
    orders: string
  }
  headers: Record<string, string>
}

// è³‡æ–™åº«é…ç½®
interface DatabaseConfig {
  host: string
  port: number
  database: string
  username: string
  password: string
  ssl: boolean
  poolSize: number
  connectionTimeout: number
  queryTimeout: number
}

// å¿«å–é…ç½®
interface CacheConfig {
  enabled: boolean
  type: 'memory' | 'redis' | 'memcached'
  host?: string
  port?: number
  ttl: number
  maxSize: number
  prefix: string
}

// æ—¥èªŒé…ç½®
interface LoggingConfig {
  level: 'debug' | 'info' | 'warn' | 'error'
  format: 'json' | 'text'
  outputs: Array<'console' | 'file' | 'syslog'>
  file?: {
    path: string
    maxSize: string
    maxFiles: number
  }
  enableRequestLogging: boolean
  enableErrorTracking: boolean
}

// å®‰å…¨é…ç½®
interface SecurityConfig {
  jwt: {
    secret: string
    expiresIn: string
    refreshExpiresIn: string
    algorithm: string
  }
  encryption: {
    algorithm: string
    keyLength: number
  }
  rateLimiting: {
    windowMs: number
    maxRequests: number
  }
  csrf: {
    enabled: boolean
    secret: string
  }
}

// åŠŸèƒ½é–‹é—œ
interface FeatureFlags {
  enableNewUI: boolean
  enableAdvancedSearch: boolean
  enableSocialLogin: boolean
  enablePaymentGateway: boolean
  enableAnalytics: boolean
  enableNotifications: boolean
}

// ç’°å¢ƒç‰¹å®šé…ç½®
type Environment = 'development' | 'testing' | 'staging' | 'production'

interface EnvironmentConfig extends BaseConfig {
  environment: Environment
}

// é…ç½®é©—è­‰çµæœ
interface ConfigValidationResult {
  isValid: boolean
  errors: string[]
  warnings: string[]
}`

const configManagerCode = `// å‹åˆ¥å®‰å…¨çš„é…ç½®ç®¡ç†å™¨
class ConfigManager {
  private config: EnvironmentConfig
  private validators: Map<string, (value: any) => boolean> = new Map()
  private listeners: Map<string, Function[]> = new Map()

  constructor(environment: Environment) {
    this.config = this.loadConfig(environment)
    this.setupValidators()
    this.validateConfig()
  }

  // å–å¾—é…ç½®å€¼
  get<K extends keyof EnvironmentConfig>(key: K): EnvironmentConfig[K] {
    return this.config[key]
  }

  // å–å¾—å·¢ç‹€é…ç½®å€¼
  getPath<T = any>(path: string): T {
    const keys = path.split('.')
    let value: any = this.config

    for (const key of keys) {
      if (value && typeof value === 'object' && key in value) {
        value = value[key]
      } else {
        throw new Error(\`Configuration path '\${path}' not found\`)
      }
    }

    return value as T
  }

  // æª¢æŸ¥é…ç½®æ˜¯å¦å­˜åœ¨
  has(path: string): boolean {
    try {
      this.getPath(path)
      return true
    } catch {
      return false
    }
  }

  // è¨­å®šé…ç½®å€¼ï¼ˆç”¨æ–¼å‹•æ…‹é…ç½®ï¼‰
  set<K extends keyof EnvironmentConfig>(key: K, value: EnvironmentConfig[K]): void {
    const oldValue = this.config[key]
    this.config[key] = value

    // é€šçŸ¥ç›£è½å™¨
    this.notifyListeners(key as string, value, oldValue)
  }

  // ç›£è½é…ç½®è®Šæ›´
  onChange<K extends keyof EnvironmentConfig>(
    key: K,
    callback: (newValue: EnvironmentConfig[K], oldValue: EnvironmentConfig[K]) => void
  ): () => void {
    const keyStr = key as string
    if (!this.listeners.has(keyStr)) {
      this.listeners.set(keyStr, [])
    }

    this.listeners.get(keyStr)!.push(callback)

    // å›å‚³å–æ¶ˆç›£è½çš„å‡½æ•¸
    return () => {
      const callbacks = this.listeners.get(keyStr)
      if (callbacks) {
        const index = callbacks.indexOf(callback)
        if (index > -1) {
          callbacks.splice(index, 1)
        }
      }
    }
  }

  // é©—è­‰é…ç½®
  validateConfig(): ConfigValidationResult {
    const errors: string[] = []
    const warnings: string[] = []

    // é©—è­‰å¿…è¦æ¬„ä½
    if (!this.config.app.name) {
      errors.push('App name is required')
    }

    if (!this.config.api.baseUrl) {
      errors.push('API base URL is required')
    }

    // é©—è­‰æ•¸å€¼ç¯„åœ
    if (this.config.app.port < 1 || this.config.app.port > 65535) {
      errors.push('Port must be between 1 and 65535')
    }

    if (this.config.api.timeout < 1000) {
      warnings.push('API timeout should be at least 1000ms')
    }

    // è‡ªå®šç¾©é©—è­‰å™¨
    for (const [path, validator] of this.validators) {
      try {
        const value = this.getPath(path)
        if (!validator(value)) {
          errors.push(\`Invalid value for \${path}\`)
        }
      } catch {
        errors.push(\`Missing required configuration: \${path}\`)
      }
    }

    return {
      isValid: errors.length === 0,
      errors,
      warnings
    }
  }

  // è¨»å†Šè‡ªå®šç¾©é©—è­‰å™¨
  addValidator(path: string, validator: (value: any) => boolean): void {
    this.validators.set(path, validator)
  }

  // è¼‰å…¥é…ç½®
  private loadConfig(environment: Environment): EnvironmentConfig {
    // åŸºç¤é…ç½®
    const baseConfig = this.getBaseConfig()

    // ç’°å¢ƒç‰¹å®šé…ç½®
    const envConfig = this.getEnvironmentConfig(environment)

    // åˆä½µé…ç½®
    return this.mergeConfigs(baseConfig, envConfig)
  }

  private getBaseConfig(): Partial<EnvironmentConfig> {
    return {
      app: {
        name: 'TypeScript Tutorial',
        version: '1.0.0',
        environment: 'development',
        port: 3000,
        host: 'localhost',
        debug: true,
        cors: {
          enabled: true,
          origins: ['*'],
          credentials: false
        }
      },
      api: {
        baseUrl: '/api/v1',
        timeout: 10000,
        retries: 3,
        rateLimit: {
          enabled: false,
          maxRequests: 100,
          windowMs: 60000
        },
        endpoints: {
          auth: '/auth',
          users: '/users',
          products: '/products',
          orders: '/orders'
        },
        headers: {
          'Content-Type': 'application/json'
        }
      },
      features: {
        enableNewUI: false,
        enableAdvancedSearch: false,
        enableSocialLogin: false,
        enablePaymentGateway: false,
        enableAnalytics: false,
        enableNotifications: false
      }
    }
  }

  private getEnvironmentConfig(environment: Environment): Partial<EnvironmentConfig> {
    const configs = {
      development: {
        app: { debug: true, port: 3000 },
        api: { baseUrl: 'http://localhost:3001/api/v1' },
        features: { enableNewUI: true }
      },
      testing: {
        app: { debug: false, port: 3002 },
        api: { baseUrl: 'http://test-api.example.com/api/v1' }
      },
      staging: {
        app: { debug: false, port: 3003 },
        api: { baseUrl: 'https://staging-api.example.com/api/v1' }
      },
      production: {
        app: { debug: false, port: 80 },
        api: { baseUrl: 'https://api.example.com/api/v1' },
        features: { enableAnalytics: true }
      }
    }

    return configs[environment] || {}
  }

  private mergeConfigs(base: any, override: any): EnvironmentConfig {
    const merged = { ...base }

    for (const key in override) {
      if (override[key] && typeof override[key] === 'object' && !Array.isArray(override[key])) {
        merged[key] = this.mergeConfigs(merged[key] || {}, override[key])
      } else {
        merged[key] = override[key]
      }
    }

    return merged as EnvironmentConfig
  }

  private setupValidators(): void {
    // è¨­å®šå…§å»ºé©—è­‰å™¨
    this.addValidator('app.port', (port: number) => port > 0 && port <= 65535)
    this.addValidator('api.timeout', (timeout: number) => timeout > 0)
    this.addValidator('api.baseUrl', (url: string) => url.length > 0)
  }

  private notifyListeners(key: string, newValue: any, oldValue: any): void {
    const callbacks = this.listeners.get(key)
    if (callbacks) {
      callbacks.forEach(callback => callback(newValue, oldValue))
    }
  }
}`

const environments = [
    {
        id: 'development',
        title: 'é–‹ç™¼ç’°å¢ƒ',
        code: `// é–‹ç™¼ç’°å¢ƒé…ç½®
const developmentConfig: Partial<EnvironmentConfig> = {
  app: {
    name: 'TypeScript Tutorial',
    version: '1.0.0',
    environment: 'development',
    port: 3000,
    host: 'localhost',
    debug: true,
    cors: {
      enabled: true,
      origins: ['http://localhost:3000', 'http://localhost:8080'],
      credentials: true
    }
  },
  api: {
    baseUrl: 'http://localhost:3001/api/v1',
    timeout: 15000,
    retries: 1,
    rateLimit: {
      enabled: false,
      maxRequests: 1000,
      windowMs: 60000
    },
    endpoints: {
      auth: '/auth',
      users: '/users',
      products: '/products',
      orders: '/orders'
    },
    headers: {
      'Content-Type': 'application/json',
      'X-Development': 'true'
    }
  },
  logging: {
    level: 'debug',
    format: 'text',
    outputs: ['console'],
    enableRequestLogging: true,
    enableErrorTracking: false
  },
  features: {
    enableNewUI: true,
    enableAdvancedSearch: true,
    enableSocialLogin: false,
    enablePaymentGateway: false,
    enableAnalytics: false,
    enableNotifications: true
  }
}`,
        explanation: 'é–‹ç™¼ç’°å¢ƒé…ç½®è‘—é‡æ–¼é™¤éŒ¯å’Œé–‹ç™¼ä¾¿åˆ©æ€§'
    },
    {
        id: 'production',
        title: 'ç”Ÿç”¢ç’°å¢ƒ',
        code: `// ç”Ÿç”¢ç’°å¢ƒé…ç½®
const productionConfig: Partial<EnvironmentConfig> = {
  app: {
    name: 'TypeScript Tutorial',
    version: '1.0.0',
    environment: 'production',
    port: 80,
    host: '0.0.0.0',
    debug: false,
    cors: {
      enabled: true,
      origins: ['https://tutorial.example.com'],
      credentials: true
    }
  },
  api: {
    baseUrl: 'https://api.example.com/api/v1',
    timeout: 10000,
    retries: 3,
    rateLimit: {
      enabled: true,
      maxRequests: 100,
      windowMs: 60000
    },
    endpoints: {
      auth: '/auth',
      users: '/users',
      products: '/products',
      orders: '/orders'
    },
    headers: {
      'Content-Type': 'application/json',
      'X-API-Version': 'v1'
    }
  },
  logging: {
    level: 'warn',
    format: 'json',
    outputs: ['file', 'syslog'],
    file: {
      path: '/var/log/app.log',
      maxSize: '10m',
      maxFiles: 5
    },
    enableRequestLogging: false,
    enableErrorTracking: true
  },
  features: {
    enableNewUI: false,
    enableAdvancedSearch: true,
    enableSocialLogin: true,
    enablePaymentGateway: true,
    enableAnalytics: true,
    enableNotifications: true
  }
}`,
        explanation: 'ç”Ÿç”¢ç’°å¢ƒé…ç½®æ³¨é‡å®‰å…¨æ€§ã€æ•ˆèƒ½å’Œç©©å®šæ€§'
    }
]

const configValidationCode = `// é…ç½®é©—è­‰ç³»çµ±
interface ValidationRule<T = any> {
  field: string
  validator: (value: T) => boolean
  message: string
  level: 'error' | 'warning'
}

class ConfigValidator {
  private rules: ValidationRule[] = []

  // æ·»åŠ é©—è­‰è¦å‰‡
  addRule<T>(rule: ValidationRule<T>): void {
    this.rules.push(rule)
  }

  // é©—è­‰é…ç½®
  validate(config: EnvironmentConfig): ConfigValidationResult {
    const errors: string[] = []
    const warnings: string[] = []

    for (const rule of this.rules) {
      try {
        const value = this.getNestedValue(config, rule.field)
        const isValid = rule.validator(value)

        if (!isValid) {
          if (rule.level === 'error') {
            errors.push(rule.message)
          } else {
            warnings.push(rule.message)
          }
        }
      } catch (error) {
        if (rule.level === 'error') {
          errors.push(\`Field '\${rule.field}' is missing\`)
        } else {
          warnings.push(\`Field '\${rule.field}' is missing\`)
        }
      }
    }

    return {
      isValid: errors.length === 0,
      errors,
      warnings
    }
  }

  private getNestedValue(obj: any, path: string): any {
    const keys = path.split('.')
    let value = obj

    for (const key of keys) {
      if (value && typeof value === 'object' && key in value) {
        value = value[key]
      } else {
        throw new Error(\`Path '\${path}' not found\`)
      }
    }

    return value
  }
}

// é è¨­é©—è­‰è¦å‰‡
function createDefaultValidator(): ConfigValidator {
  const validator = new ConfigValidator()

  // æ‡‰ç”¨ç¨‹å¼é…ç½®é©—è­‰
  validator.addRule({
    field: 'app.name',
    validator: (value: string) => typeof value === 'string' && value.length > 0,
    message: 'App name must be a non-empty string',
    level: 'error'
  })

  validator.addRule({
    field: 'app.port',
    validator: (value: number) => Number.isInteger(value) && value > 0 && value <= 65535,
    message: 'Port must be a valid integer between 1 and 65535',
    level: 'error'
  })

  // API é…ç½®é©—è­‰
  validator.addRule({
    field: 'api.baseUrl',
    validator: (value: string) => {
      try {
        new URL(value)
        return true
      } catch {
        return false
      }
    },
    message: 'API base URL must be a valid URL',
    level: 'error'
  })

  validator.addRule({
    field: 'api.timeout',
    validator: (value: number) => value >= 1000 && value <= 60000,
    message: 'API timeout should be between 1000ms and 60000ms',
    level: 'warning'
  })

  // å®‰å…¨é…ç½®é©—è­‰
  validator.addRule({
    field: 'security.jwt.secret',
    validator: (value: string) => value && value.length >= 32,
    message: 'JWT secret must be at least 32 characters long',
    level: 'error'
  })

  return validator
}`

const dynamicExamples = [
    {
        id: 'feature-flags',
        title: 'åŠŸèƒ½é–‹é—œ',
        code: `// å‹•æ…‹åŠŸèƒ½é–‹é—œç³»çµ±
interface FeatureFlag {
  name: string
  enabled: boolean
  conditions?: FeatureCondition[]
  rolloutPercentage?: number
  validFrom?: Date
  validUntil?: Date
}

interface FeatureCondition {
  type: 'user' | 'region' | 'version' | 'custom'
  operator: 'equals' | 'in' | 'contains' | 'matches'
  value: any
}

class FeatureFlagManager {
  private flags: Map<string, FeatureFlag> = new Map()
  private userId?: string
  private userRegion?: string
  private appVersion?: string

  constructor(config: { userId?: string; userRegion?: string; appVersion?: string }) {
    this.userId = config.userId
    this.userRegion = config.userRegion
    this.appVersion = config.appVersion
  }

  // è¨­å®šåŠŸèƒ½é–‹é—œ
  setFlag(flag: FeatureFlag): void {
    this.flags.set(flag.name, flag)
  }

  // æª¢æŸ¥åŠŸèƒ½æ˜¯å¦å•Ÿç”¨
  isEnabled(flagName: string): boolean {
    const flag = this.flags.get(flagName)
    if (!flag) return false

    // æª¢æŸ¥åŸºæœ¬å•Ÿç”¨ç‹€æ…‹
    if (!flag.enabled) return false

    // æª¢æŸ¥æ™‚é–“ç¯„åœ
    if (flag.validFrom && new Date() < flag.validFrom) return false
    if (flag.validUntil && new Date() > flag.validUntil) return false

    // æª¢æŸ¥æ¨å‡ºç™¾åˆ†æ¯”
    if (flag.rolloutPercentage !== undefined) {
      const hash = this.hashUserId(this.userId || 'anonymous')
      if (hash % 100 >= flag.rolloutPercentage) return false
    }

    // æª¢æŸ¥æ¢ä»¶
    if (flag.conditions) {
      return flag.conditions.every(condition => this.evaluateCondition(condition))
    }

    return true
  }

  private evaluateCondition(condition: FeatureCondition): boolean {
    let actualValue: any

    switch (condition.type) {
      case 'user':
        actualValue = this.userId
        break
      case 'region':
        actualValue = this.userRegion
        break
      case 'version':
        actualValue = this.appVersion
        break
      default:
        return true
    }

    switch (condition.operator) {
      case 'equals':
        return actualValue === condition.value
      case 'in':
        return Array.isArray(condition.value) && condition.value.includes(actualValue)
      case 'contains':
        return typeof actualValue === 'string' && actualValue.includes(condition.value)
      case 'matches':
        return typeof actualValue === 'string' && new RegExp(condition.value).test(actualValue)
      default:
        return false
    }
  }

  private hashUserId(userId: string): number {
    let hash = 0
    for (let i = 0; i < userId.length; i++) {
      const char = userId.charCodeAt(i)
      hash = ((hash << 5) - hash) + char
      hash = hash & hash // è½‰æ›ç‚º 32 ä½æ•´æ•¸
    }
    return Math.abs(hash)
  }
}`,
        explanation: 'å¯¦ç¾éˆæ´»çš„åŠŸèƒ½é–‹é—œç³»çµ±ï¼Œæ”¯æ´æ¢ä»¶å¼å•Ÿç”¨å’Œæ®µè½æ¨å‡º'
    },
    {
        id: 'remote-config',
        title: 'é ç«¯é…ç½®',
        code: `// é ç«¯é…ç½®ç®¡ç†
interface RemoteConfigOptions {
  endpoint: string
  pollInterval: number
  cacheKey: string
  fallbackConfig: any
}

class RemoteConfigManager {
  private options: RemoteConfigOptions
  private config: any = {}
  private listeners: Function[] = []
  private pollTimer?: NodeJS.Timeout

  constructor(options: RemoteConfigOptions) {
    this.options = options
    this.loadFromCache()
    this.startPolling()
  }

  // ç²å–é…ç½®å€¼
  get<T = any>(key: string, defaultValue?: T): T {
    const keys = key.split('.')
    let value = this.config

    for (const k of keys) {
      if (value && typeof value === 'object' && k in value) {
        value = value[k]
      } else {
        return defaultValue !== undefined ? defaultValue : this.getFallbackValue(key)
      }
    }

    return value as T
  }

  // ç›£è½é…ç½®è®Šæ›´
  onChange(callback: (newConfig: any, oldConfig: any) => void): () => void {
    this.listeners.push(callback)

    return () => {
      const index = this.listeners.indexOf(callback)
      if (index > -1) {
        this.listeners.splice(index, 1)
      }
    }
  }

  // æ‰‹å‹•åˆ·æ–°é…ç½®
  async refresh(): Promise<void> {
    try {
      const response = await fetch(this.options.endpoint, {
        headers: {
          'Accept': 'application/json',
          'Cache-Control': 'no-cache'
        }
      })

      if (!response.ok) {
        throw new Error(\`HTTP \${response.status}: \${response.statusText}\`)
      }

      const newConfig = await response.json()
      const oldConfig = { ...this.config }

      this.config = newConfig
      this.saveToCache()

      // é€šçŸ¥ç›£è½å™¨
      this.listeners.forEach(listener => listener(newConfig, oldConfig))

    } catch (error) {
      console.error('Failed to fetch remote config:', error)
    }
  }

  // åœæ­¢è‡ªå‹•åˆ·æ–°
  stop(): void {
    if (this.pollTimer) {
      clearInterval(this.pollTimer)
      this.pollTimer = undefined
    }
  }

  private startPolling(): void {
    // ç«‹å³è¼‰å…¥ä¸€æ¬¡
    this.refresh()

    // è¨­å®šå®šæœŸè¼ªè©¢
    this.pollTimer = setInterval(() => {
      this.refresh()
    }, this.options.pollInterval)
  }

  private loadFromCache(): void {
    try {
      const cached = localStorage.getItem(this.options.cacheKey)
      if (cached) {
        this.config = JSON.parse(cached)
      }
    } catch (error) {
      console.warn('Failed to load config from cache:', error)
    }
  }

  private saveToCache(): void {
    try {
      localStorage.setItem(this.options.cacheKey, JSON.stringify(this.config))
    } catch (error) {
      console.warn('Failed to save config to cache:', error)
    }
  }

  private getFallbackValue(key: string): any {
    const keys = key.split('.')
    let value = this.options.fallbackConfig

    for (const k of keys) {
      if (value && typeof value === 'object' && k in value) {
        value = value[k]
      } else {
        return undefined
      }
    }

    return value
  }
}`,
        explanation: 'å¯¦ç¾å¾é ç«¯ä¼ºæœå™¨å‹•æ…‹è¼‰å…¥é…ç½®çš„ç®¡ç†ç³»çµ±'
    }
]

const usageExampleCode = `// å®Œæ•´ä½¿ç”¨ç¯„ä¾‹
// 1. åˆå§‹åŒ–é…ç½®ç®¡ç†
const configManager = new ConfigManager('development')

// 2. é©—è­‰é…ç½®
const validation = configManager.validateConfig()
if (!validation.isValid) {
  console.error('Configuration errors:', validation.errors)
  process.exit(1)
}

if (validation.warnings.length > 0) {
  console.warn('Configuration warnings:', validation.warnings)
}

// 3. ä½¿ç”¨é…ç½®
const apiConfig = configManager.get('api')
const dbConfig = configManager.get('database')
const features = configManager.get('features')

// 4. è¨­å®šåŠŸèƒ½é–‹é—œ
const featureFlags = new FeatureFlagManager({
  userId: 'user123',
  userRegion: 'US',
  appVersion: '1.0.0'
})

featureFlags.setFlag({
  name: 'newUI',
  enabled: true,
  rolloutPercentage: 50,
  conditions: [
    {
      type: 'region',
      operator: 'in',
      value: ['US', 'CA']
    }
  ]
})

// 5. è¨­å®šé ç«¯é…ç½®
const remoteConfig = new RemoteConfigManager({
  endpoint: 'https://api.example.com/config',
  pollInterval: 60000, // 1 åˆ†é˜
  cacheKey: 'app-remote-config',
  fallbackConfig: {
    maxRetries: 3,
    timeout: 5000
  }
})

// 6. åœ¨æ‡‰ç”¨ç¨‹å¼ä¸­ä½¿ç”¨
class ApiService {
  private client: AxiosInstance

  constructor() {
    const config = configManager.get('api')

    this.client = axios.create({
      baseURL: config.baseUrl,
      timeout: config.timeout,
      headers: config.headers
    })

    // ç›£è½é…ç½®è®Šæ›´
    remoteConfig.onChange((newConfig) => {
      this.updateClientConfig(newConfig)
    })
  }

  async getUsers(): Promise<User[]> {
    // æª¢æŸ¥åŠŸèƒ½é–‹é—œ
    if (!featureFlags.isEnabled('newAPI')) {
      return this.getLegacyUsers()
    }

    // ä½¿ç”¨é ç«¯é…ç½®
    const maxRetries = remoteConfig.get('maxRetries', 3)
    const timeout = remoteConfig.get('timeout', 5000)

    // åŸ·è¡Œ API èª¿ç”¨
    const response = await this.client.get('/users', {
      timeout,
      // å…¶ä»–é…ç½®...
    })

    return response.data
  }

  private updateClientConfig(newConfig: any): void {
    if (newConfig.api) {
      this.client.defaults.timeout = newConfig.api.timeout
      this.client.defaults.baseURL = newConfig.api.baseUrl
    }
  }

  private async getLegacyUsers(): Promise<User[]> {
    // èˆŠç‰ˆ API å¯¦ç¾
    return []
  }
}

// 7. åœ¨ Vue å…ƒä»¶ä¸­ä½¿ç”¨
const apiService = new ApiService()

// ç›£è½é…ç½®è®Šæ›´ä¸¦æ›´æ–° UI
configManager.onChange('features', (newFeatures) => {
  // æ›´æ–° UI ç‹€æ…‹
  console.log('Features updated:', newFeatures)
})

export { configManager, featureFlags, remoteConfig, apiService }`

function runExample(code: string) {
    console.log('Running example:', code)
}

function completeSection() {
    emit('complete')
}
</script>

<style scoped>
.configuration-types {
    max-width: 100%;
    margin: 0 auto;
    padding: 0;
}

.section-intro {
    margin-bottom: 2rem;
}

.section-intro h2 {
    font-size: 1.75rem;
    color: #2d3748;
    margin-bottom: 1rem;
}

.intro-text {
    font-size: 1.1rem;
    line-height: 1.6;
    color: #4a5568;
}

.config-principles {
    margin-bottom: 3rem;
}

.config-principles h3 {
    font-size: 1.5rem;
    color: #2d3748;
    margin-bottom: 1rem;
}

.principles-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 1.5rem;
}

.principle-card {
    padding: 1.5rem;
    background: white;
    border: 1px solid #e2e8f0;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
}

.principle-card h4 {
    margin-bottom: 0.75rem;
    color: #2d3748;
    font-size: 1.1rem;
}

.principle-card p {
    margin: 0;
    color: #4a5568;
    line-height: 1.5;
}

.config-types,
.config-manager,
.config-validation,
.practical-usage {
    margin-bottom: 3rem;
}

.config-types h3,
.config-manager h3,
.config-validation h3,
.practical-usage h3 {
    font-size: 1.5rem;
    color: #2d3748;
    margin-bottom: 1rem;
}

.environment-configs,
.dynamic-config {
    margin-bottom: 3rem;
}

.environment-configs h3,
.dynamic-config h3 {
    font-size: 1.5rem;
    color: #2d3748;
    margin-bottom: 1rem;
}

.env-tabs,
.dynamic-tabs {
    display: flex;
    gap: 0.5rem;
    margin-bottom: 1rem;
    flex-wrap: wrap;
}

.tab-button {
    padding: 0.5rem 1rem;
    border: 1px solid #cbd5e0;
    border-radius: 4px 4px 0 0;
    background: #f7fafc;
    color: #4a5568;
    cursor: pointer;
    transition: all 0.2s;
    white-space: nowrap;
}

.tab-button.active {
    background: white;
    color: #2d3748;
    border-bottom-color: white;
}

.env-content,
.dynamic-content {
    border: 1px solid #cbd5e0;
    border-radius: 0 8px 8px 8px;
    background: white;
    padding: 1.5rem;
}

.security-practices {
    margin-bottom: 3rem;
}

.security-practices h3 {
    font-size: 1.5rem;
    color: #2d3748;
    margin-bottom: 1rem;
}

.security-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 1.5rem;
}

.security-card {
    padding: 1.5rem;
    background: white;
    border: 1px solid #e2e8f0;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
}

.security-card h4 {
    margin-bottom: 1rem;
    color: #2d3748;
}

.security-card ul {
    margin: 0;
    padding-left: 1.5rem;
}

.security-card li {
    margin-bottom: 0.5rem;
    color: #4a5568;
}

.navigation-footer {
    text-align: center;
    padding-top: 2rem;
    border-top: 1px solid #e2e8f0;
}

.btn-complete {
    padding: 0.75rem 2rem;
    background: #48bb78;
    color: white;
    border: none;
    border-radius: 6px;
    font-size: 1rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s;
}

.btn-complete:hover {
    background: #38a169;
    transform: translateY(-1px);
}

@media (max-width: 768px) {

    .principles-grid,
    .security-grid {
        grid-template-columns: 1fr;
    }

    .env-tabs,
    .dynamic-tabs {
        flex-direction: column;
    }

    .tab-button {
        border-radius: 4px;
    }

    .env-content,
    .dynamic-content {
        border-radius: 8px;
    }
}
</style>
